# 141. Linked List Cycle

https://leetcode.com/problems/linked-list-cycle/

---

# Description

Given a linked list, determine if it has a cycle in it.

To represent a cycle in the given linked list, we use an integer `pos` which represents the position (0-indexed) in the linked list where tail connects to. If `pos` is `-1`, then there is no cycle in the linked list.

**Example 1**:

<pre><code>
<b>Input</b>: head = [3,2,0,-4], pos = 1
<b>Output</b>: true
<b>Expanation</b>: There is a cycle in the linked list, where tail connects to the second node.
</code></pre>

![image1](OtherFiles/circularlinkedlist.png)

**Example 2**:

<pre><code>
<b>Input</b>: head = [1,2], pos = 0
<b>Output</b>: true
<b>Expanation</b>: There is a cycle in the linked list, where tail connects to the first node.
</code></pre>

![image2](OtherFiles/circularlinkedlist_test2.png)

**Example 3**:

<pre><code>
<b>Input</b>: head = [1], pos = -1
<b>Output</b>: false
<b>Expanation</b>: There is no cycle in the linked list.
</code></pre>

![image3](OtherFiles/circularlinkedlist_test3.png)

**Follow up**:

Can you solve it using *O(1)* (i.e. constant) memory?

---

# Solution

## 1. Hash Set

Maintaining a hash set to record the nodes that visited before.

**Python**
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        # Hash Set
        visited = set()
        node = head
        while node:
            if node in visited:
                return True
            visited.add(node)
            node = node.next
        return False
```

**Time Complexity** : $O(n)$

**Space Complexity** :$O(n)$

## Two Pointers

Ref: https://leetcode.com/problems/linked-list-cycle/solution/

Suppose there are two runners, each time one move 1 step and the other moves 2 step. Then, if there is a cycle, they will eventually meet each others.

**Python**
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        # Two Pointers
        if not head or not head.next: 
            return False
        slow, fast = head, head.next
        while slow != fast:
            if not fast or not fast.next: 
                return False
            slow = slow.next
            fast = fast.next.next
        return True
```

**Time Complexity** : $O(n)$ (no cycle) / $O(n+k)$ (has cycle)

If there is no cycle, the fast runner runs to the end and finished. $O(n)$

If there is a cycle, then they will meet at a node in the cycle. Suppose the length of cycle is $k$, the fast runner will catch the slow runner before the slow runner finish a cycle. Hence the total time complexity is $O(n+k)$.

**Space Complexity** :$O(1)$