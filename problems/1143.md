# 1143. Longest Common Subsequence

https://leetcode.com/problems/longest-common-subsequence/

---

# Description

Given `n` balloons, indexed from `0` to `n-1`. Each balloon is painted with a number on it represented by array `nums`. You are asked to burst all the balloons. If the you burst balloon `i` you will get `nums[left] * nums[i] * nums[right]` coins. Here `left` and `right` are adjacent indices of `i`. After the burst, the `left` and `right` then becomes adjacent.

Find the maximum coins you can collect by bursting the balloons wisely.

**Note**:

- You may imagine `nums[-1] = nums[n] = 1`. They are not real therefore you can not burst them.
- 0 ≤ `n` ≤ 500, 0 ≤ `nums[i]` ≤ 100

**Example**:

<pre><code>
<b>Input</b>: [3,1,5,8]
<b>Output</b>: 167 
<b>Explanation</b>: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
             coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
</code></pre>

---

# Solution

## 1. Dynamic Programming

DP[i][j]: length of longest common subsequene of text1[:i] and text2[:j]

Choice: if a character in or out the common subsequence.

If text1[i] == text2[j]: then the character in the common subsequence, DP[i][j] = DP[i-1][j-1] + 1

Else: the two characters not both in the current common subsequence, same as before, check next, DP[i][j] = max(DP[i-1][j], DP[i][j-1])

**Python 1**
```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        DP = [[0 for _ in range(len(text2)+1)] for _ in range(len(text1)+1)]
        
        # base case
        # DP[0][] = DP[][0] = 0
        
        for i in range(1, len(text1)+1):
            for j in range(1, len(text2)+1):
                if text1[i-1] == text2[j-1]:
                    DP[i][j] = DP[i-1][j-1]+1
                else:
                    DP[i][j] = max(DP[i-1][j], DP[i][j-1])
        return DP[-1][-1]
```

**Python 2**
```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        DP1 = [0 for _ in range(len(text2)+1)]
        DP2 = DP1[:]
        
        for i in range(1, len(text1)+1):
            for j in range(1, len(text2)+1):
                if text1[i-1] == text2[j-1]:
                    DP2[j] = DP1[j-1]+1
                else:
                    DP2[j] = max(DP1[j], DP2[j-1])
            
            DP1 = DP2[:]
        return DP1[-1]
```

**Time Complexity** : $O(N^2)$

**Space Complexity** :$O(N)$ (**Python 1**) | $O(1)$ (**Python 2**)